\chapter{Vorarbeit}
\label{chap:whezzy_ugprade}
\begin{itemize}
	\item Update auf Weezy
	\item symlink \verb#09_linux_xen# in /etc/grub.d erstellt
	\item \verb#/etc/network/interfaces#: \verb#auto eth0# added
	\item rootpw changed \verb#123#
	\item Nameserver in \verb#/etc/resolv.conf# auskommentiert da er grad ned antwortet (Routingproblem und andererseits antwortet er nicht auf Welt) 
\end{itemize}

\chapter{Storage}
\section{RAID}
Erstelle RAID über \verb#sdb2# und \verb#sdc1#
\setupVerbatim{bash}
\begin{verbatim}
apt-get install gdisk
gdisk /dev/sdb
# gdisk GPT Partition ~1M Rest Maximal erstellt.
sgdisk -R=/dev/sdc /dev/sdb
sgdisk -G /dev/sdb
# Partitionstabelle kopiert und GUID neu
mdadm --create /dev/md1 -n 2 -l 1 /dev/sdb2 /dev/sdc2
#	-n	Number of Devices
#	-l	RAID Level
dmesg
\end{verbatim}
\setupVerbatimOut
\begin{verbatim}
[  253.106706]  sdb: sdb1 sdb2
[  364.210743]  sdc: sdc1 sdc2
[  373.659167]  sdb: sdb1 sdb2
[  701.414204] md: bind<sdb2>
[  701.415194] md: bind<sdc2>
[  701.425611] md: raid1 personality registered for level 1
[  701.425853] bio: create slab <bio-1> at 1
[  701.425897] md/raid1:md1: not clean -- starting background reconstruction
[  701.425898] md/raid1:md1: active with 2 out of 2 mirrors
[  701.425913] md1: detected capacity change from 0 to 499971325952
[  701.433300]  md1: unknown partition table
[ 1223.952091] md: resync of RAID array md1
[ 1223.952093] md: minimum _guaranteed_  speed: 1000 KB/sec/disk.
[ 1223.952095] md: using maximum available idle IO bandwidth (but not more than 200000 KB/sec) for resync.
[ 1223.952097] md: using 128k window, over a total of 488253248k.
\end{verbatim}

\section{LVM}
\todo{Schönen text}
\setupVerbatim{bash}
\begin{verbatim}
#physical volume create
pvcreate /dev/md1 
#volumegroup create 
vgcreate storage /dev/md1
#2 Logical Volumes fuer VMs
lvcreate -n guest1 -L 10G storage
lvcreate -n guest2 -L 20G storage
\end{verbatim} 

\chapter{Open vSwitch}
\label{chap:ovs}
\todo{Schönen text}
\setupVerbatim{bash}
\begin{verbatim}
apt-get instal openvswitch-brcompat openvswitch-switch openvswitch-datapath-dkms
modprobe openvswitch-mod
dmesg
\end{verbatim} 
\setupVerbatimOut
\begin{verbatim}
[ 2377.104677] openvswitch_mod: Open vSwitch switching datapath 1.4.2, built Apr 30 2013 15:47:50
\end{verbatim}
In Datei \verb#/etc/default/openvswitch-switch#: \verb#BRCOMPAT=yes# gesetzt
\setupVerbatimBash
\begin{verbatim}
/etc/init.d/openvswitch-switch start
ovs-vsctl add-br br-guest
ovs-vsctl show
\end{verbatim}
\setupVerbatimOut
\begin{verbatim}
b01c6804-1ad5-4294-98d1-b6aa0a8f6155
    Bridge br-guest
        Port br-guest
            Interface br-guest
                type: internal
    ovs_version: "1.4.2"
\end{verbatim} 
\setupVerbatimBash
\begin{verbatim}
ovs-vsctl add-port br-guest eth0
ovs-vsctl show
\end{verbatim}
\setupVerbatimOut
\begin{verbatim}
b01c6804-1ad5-4294-98d1-b6aa0a8f6155
     Bridge br-guest
        Port "eth0"
            Interface "eth0"
        Port br-guest
            Interface br-guest
                type: internal
    ovs_version: "1.4.2"
\end{verbatim}
\begin{itemize}
\item In \verb#/etc/network/interfaces#: \verb#eth0# durch \verb#br-guest# ersetzt. 
\item IP auf eth0 zurückgesetzt. 
\item Mittels Ping die Bridge getestet.
\end{itemize}
\chapter{VM}
\todo{Schönen text}
\setupVerbatim{bash}
\begin{verbatim}
xen-create-image --ip 192.168.10.12  --lvm=storage --hostname=guest1 --vcpus=2 --dist wheezy
\end{verbatim}
\setupVerbatimOut
\begin{verbatim}                                                  
WARNING                                           
-------                                           
                                                  
  You appear to have a missing vif-script, or network-script, in the
 Xen configuration file /etc/xen/xend-config.sxp. 
                                                  
  Please fix this and restart Xend, or your guests will not be able
 to use any networking!                           
                                                  
WARNING:  No gateway address specified!           
WARNING:  No netmask address specified!           
                                                  
General Information                               
--------------------                              
Hostname       :  guest1                          
Distribution   :  wheezy                          
Mirror         :  http://cdn.debian.net/debian/   
Partitions     :  swap            128Mb (swap)    
                  /               4Gb   (ext3)    
Image type     :  full                            
Memory size    :  128Mb                           
Kernel path    :  /boot/vmlinuz-3.2.0-4-amd64     
Initrd path    :  /boot/initrd.img-3.2.0-4-amd64  
                                                  
Networking Information                            
----------------------                            
IP Address 1   : 192.168.10.12 [MAC: 00:16:3E:95:61:15]
                                                  
                                                  
Creating swap on /dev/storage/guest1-swap         
Done                                              
                                                  
Creating ext3 filesystem on /dev/storage/guest1-disk
Done                                              
Installation method: debootstrap
Done

Running hooks
Done

No role scripts were specified.  Skipping

Creating Xen configuration file
Done

No role scripts were specified.  Skipping
Setting up root password
Generating a password for the new guest.
All done


Logfile produced at:
         /var/log/xen-tools/guest1.log

Installation Summary
---------------------
Hostname        :  guest1
Distribution    :  wheezy
IP-Address(es)  :  192.168.10.12 
RSA Fingerprint :  01:06:31:35:f0:d4:f0:70:54:d3:0f:f2:d4:90:ba:e1
Root Password   :  JzXi4Ufg

\end{verbatim}
Passwort auf 123 geändert!

\begin{itemize}
	\item Memory in \verb#/etc/xen/guest1.cfg# erhöht auf 512 MB
	\item VM mit \verb#xm create /etc/xen/guest1.cfg# gestartet
	\item \verb#vif1.0# wurde erstellt und mit br-guest verbunden
	\item mittels \verb#xm console guest1# in VM gewechselt.
	\item VM hat Konnectivität. Getestet mittels \verb#ping#.
	\item \verb#Ctrl+AltGr+]# beendet \verb#xm console#
\end{itemize}

\section{2. VM sowie Zusätzliche Bridge für VM-Interconnect}
\begin{itemize}
	\item \verb#ovs-vsctl add-br br-vmonly#
	\item \verb#xen-create-image --ip 192.168.10.13  --lvm=storage --hostname=guest2 --vcpus=2 --bridge=br-guest#
	\item Config von Guest1 angepasst um 2. Intervace auf vmonly zu erhalten. Shutdown - Create
	\item Guest2 gestartet
	\item Host lernt Routing und NAT
	\item iperf auf guest1 zu guest2 \verb#iperf -c 192.168.2.2#
\end{itemize}

\setupVerbatimOut
\begin{verbatim}
------------------------------------------------------------
Client connecting to 192.168.2.2, TCP port 5001
TCP window size: 23.5 KByte (default)
------------------------------------------------------------
[  3] local 192.168.2.1 port 57804 connected with 192.168.2.2 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec  9.21 GBytes  7.91 Gbits/sec


------------------------------------------------------------
Client connecting to 192.168.1.2, TCP port 5001
TCP window size: 23.5 KByte (default)
------------------------------------------------------------
[  3] local 192.168.1.1 port 56132 connected with 192.168.1.2 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec  10.6 GBytes  9.12 Gbits/sec
\end{verbatim}
tcpdump zeigt interessante Ethernet-Framegrößen 65226. Ping mit höherer MTU funktioniert wenn man Interfaces in Gästen, Bridge unf vifs entsprechend anpasst.
\setupVerbatimOut
\begin{verbatim}
17:45:48.414535 00:16:3e:32:d0:3e > 00:16:3e:95:de:ad, ethertype IPv4 (0x0800), length 65226: (tos 0x0, ttl 64, id 25535, offset 0, flags [DF], proto TCP (6), length 65212)
    192.168.1.2.57025 > 192.168.1.1.5001: Flags [.], seq 14811337:14876497, ack 0, win 913, options [nop,nop,TS val 396548 ecr 356977], length 65160
17:45:48.414540 00:16:3e:32:d0:3e > 00:16:3e:95:de:ad, ethertype IPv4 (0x0800), length 65226: (tos 0x0, ttl 64, id 25580, offset 0, flags [DF], proto TCP (6), length 65212)
    192.168.1.2.57025 > 192.168.1.1.5001: Flags [P.], seq 14876497:14941657, ack 0, win 913, options [nop,nop,TS val 396548 ecr 356977], length 65160
17:45:48.414542 00:16:3e:32:d0:3e > 00:16:3e:95:de:ad, ethertype IPv4 (0x0800), length 65226: (tos 0x0, ttl 64, id 25625, offset 0, flags [DF], proto TCP (6), length 65212)
    192.168.1.2.57025 > 192.168.1.1.5001: Flags [.], seq 14941657:15006817, ack 0, win 913, options [nop,nop,TS val 396548 ecr 356977], length 65160
17:45:48.414559 00:16:3e:95:de:ad > 00:16:3e:32:d0:3e, ethertype IPv4 (0x0800), length 66: (tos 0x0, ttl 64, id 54265, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.1.1.5001 > 192.168.1.2.57025: Flags [.], cksum 0x837a (incorrect -> 0x86f4), seq 0, ack 14876497, win 16397, options [nop,nop,TS val 356977 ecr 396548], length 0
17:45:48.414571 00:16:3e:95:de:ad > 00:16:3e:32:d0:3e, ethertype IPv4 (0x0800), length 66: (tos 0x0, ttl 64, id 54266, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.1.1.5001 > 192.168.1.2.57025: Flags [.], cksum 0x837a (incorrect -> 0x886b), seq 0, ack 14941657, win 16397, options [nop,nop,TS val 356977 ecr 396548], length 0
17:45:48.414576 00:16:3e:95:de:ad > 00:16:3e:32:d0:3e, ethertype IPv4 (0x0800), length 66: (tos 0x0, ttl 64, id 54267, offset 0, flags [DF], proto TCP (6), length 52)^C
    192.168.1.1.5001 > 192.168.1.2.57025: Flags [.], cksum 0x837a (incorrect -> 0x91f8), seq 0, ack 15006817, win 14327, options [nop,nop,TS val 356977 ecr 396548], length 0
\end{verbatim}

\chapter{Ata-Over-Ethernet}
\label{chap:aoe}
\section{Einrichtung Kernel Modul aoe auf pcvirt01 + pcvirt02}
\setupVerbatimOut

\begin{verbatim}
# Test ob AOE Kernel unterstützt
grep ATA_OVER /boot/config-`uname -r`
CONFIG_ATA_OVER_ETH=m

# Lade AOE Modul
modprobe aoe

# Einfügen in /etc/modules bei pcvirt01 + pcvirt02,
# damit Modul beim start geladen wird
aoe
\end{verbatim}

\section{Einrichtung vbladed auf pcvirt01}

\setupVerbatimOut
\begin{verbatim}
# Guest1 runterfahren (da dessen Blockdevices freigegebenwerden sollen)
xm shutdown guest1

# Disk und Swap als AOE Target zur Verfügung stellen
root@pcvirt01:/etc/xen# vbladed 0 1 br-guest /dev/storage/guest1-disk  
root@pcvirt01:/etc/xen# vbladed 0 2 br-guest /dev/storage/guest1-swap

# und ab damit in die rc.local damit persistent nach reboot
\end{verbatim}

\section{Einrichtung des Initiators pcvirt02}

\setupVerbatimOut
\begin{verbatim}
# Da Interface eth0 noch down auf pcvirt02, wird das zuerst analog,
# wie auf pcvirt01 konfiguiert (nur ohne OpenVSwitch)

# Schnellmaßnahmen
brctl addbr br-guest
brctl addif br-guest eth0
ifconfig br-guest up

# Erstelle config für /etc/network/interfaces 
auto br-guest
iface br-guest inet static
        address 192.168.1.132
        netmask 255.255.255.0
        bridge_ports eth0
\end{verbatim}

\section{Testen ob ATA-over-Ethernet gefunden wird}

\setupVerbatimOut
\begin{verbatim}
# Erkenne AOE 
root@pcvirt02:~# aoe-discover 
root@pcvirt02:~# aoe-stat                                                       
      e0.1         4.294GB br-guest up            
      e0.2         0.134GB br-guest up  
\end{verbatim}

\section{Dirty Hack da Ata Initiator sich nicht auf lokales Target verbinden kann (auf pcvirt1)}

\setupVerbatimOut
\begin{verbatim}
# Dirty symbolic links auf lokale devices auf pcvirt01
ln -s /dev/storage/guest1-disk /dev/etherd/e0.1
ln -s /dev/storage/guest1-swap /dev/etherd/e0.2 
\end{verbatim}

\chapter{Live Migration einer VM}

\section{Konfiguration von xend auf beiden Rechnern}

\setupVerbatimOut
\begin{verbatim}
# Aktiviere Migration in /etc/xen/xend-config.sxp
< (xend-relocation-server yes)
< (xend-relocation-hosts-allow '')
---
> #(xend-relocation-server no)
> #(xend-relocation-hosts-allow '')

# Anschließend Neustart von xend
/etc/init.d/xen restart
\end{verbatim}

\section{Konfiguration von guest1}

guest1 soll migrierbar gemacht werden. Dazu wurden bereits dessen Blockdevices via Ata-over-Ethernet exportiert. Jetzt müssen diese A-o-E Devices auch in der Xen Konfig
 verwendet werden.
\setupVerbatimOut
\begin{verbatim}
# Verändere Guest Konfig auf pc-virt01
disk        = [
                  'phy:/dev/storage/guest1-disk,xvda2,w',
                  'phy:/dev/storage/guest1-swap,xvda1,w',
              ]
# muss heißen
disk        = [
                  'phy:/dev/etherd/e0.1,xvda2,w',
                  'phy:/dev/etherd/e0.2,xvda1,w',
              ]
\end{verbatim}

\section{Live Migration der VM guest1 von pcvirt1 nach pcvirt2}

\subsection{1. Versuch $\Rightarrow$ Bridge fehlt}
\setupVerbatimOut
\begin{verbatim}
# Starte VM auf pcvirt1
xm create guest01.cfg

# Migriere VM von pcvirt1 nach pcvirt2
xm migrate --live guest01 192.168.1.132
\end{verbatim}

Die Migration schlägt fehl, der Maschinenstatus ist verloren. Ursache: Fehlende Brige br-vmonly auf pcvirt2
\\
$\Rightarrow$ Warum wird das nicht in der Signalling Phase geprüft und die Migartion abgebrochen ohne dass der VM State verloren geht

\subsection {2. Versuch $\Rightarrow$ Kernel fehlt}
\setupVerbatimOut
\begin{verbatim}
# Starte VM auf pcvirt1
xm create guest01.cfg

# Lege 2. Bridge auf pcvirt2 an
brctl addbr br-vmonly

# Migriere VM von pcvirt1 nach pcvirt2
xm migrate --live guest01 192.168.1.132
\end{verbatim}

Migration schlägt wieder fehl. Ursache: VM verwendet neueren Kernel, der auf Zielsystem pcvirt2 nicht verfügbar ist.
\\
\\
\large
\textbf{$\Rightarrow$ Warum wird das nicht in der Signalling Phase geprüft  \dots}
\normalsize

\subsection {3. Versuch $\Rightarrow$ Falsche Xen Versionen}
\setupVerbatimOut
\begin{verbatim}
# Es wird der alte Kernel für den Guest konfiguiert

# Starte VM auf pcvirt1
xm create guest01.cfg

# Migriere VM von pcvirt1 nach pcvirt2
xm migrate --live guest01 192.168.1.132
\end{verbatim}

Migration schlägt wieder fehl. Ursache: VMs lassen sich bei Xen nur auf der gleichen Version live migrieren. Lediglich eine Live Migration von einer Xen Version zur nächst höheren ist möglich (vgl. \url{http://wiki.xen.org/wiki/Xen_Version_Compatibility})
\\
\\
\Large
\textbf{$\Rightarrow$ Warum wird das nicht in der Signalling Phase geprüft  \dots}
\normalsize

\subsection {4. Versuch $\surd$ }
\setupVerbatimOut
\begin{verbatim}
# Nun wird die VM auf pcvirt2 gestartet 
xm create guest01.cfg

# Migriere VM von pcvirt2 nach pcvirt1
xm migrate --live guest01 192.168.1.131
\end{verbatim}

Migration erfolgreich, Netwerkdowntime $<$ als 100ms, da \verb|ping -i 0.1| \verb| -w 0.1 <VM-IP>| keinen Loss anzeigte

\section{Beobachtungen der Migration mit tshark}

\subsection{Erfolgreiche Migration von Xen 4.0 auf 4.1}

Es wird eine Simple TCP Verbindung zwischen beiden Hosts aufgebaut. Dabei meldet sich pcvirt2 mit dem \verb|(receive)| command bei pcvirt1 an. Dieser erlaubt den Empfang über die Rückmeldung \verb|(ready receive)|. Anschließend schickt pcvirt2 an den pcvirt1 den LinuxGuestRecord mit sämtlichen Settings und States der VM. Darauf schickt pcvirt2 die RAM Inhalte von pcvirt1. Den erfolgreichen Empfang quitiert pcvirt2 mit einem \verb|(ok)|.

\setupVerbatimOut
\begin{verbatim}
# Von >=pcvirt2 nach <=pcvirt1

> (receive)
< (ready receive)
> LinuxGuestRecord
(domain (domid 9) (cpu_weight 256) (cpu_cap 0) (on_crash restart) (uuid 42ed8dbf-c245-2937-f1fc-b2d6d1620aa2) (bootloader_args ) (vcpus 3) (name guest1) (on_poweroff destroy) (on_reboot restart) (cpus (() () ())) (description ) (bootloader ) (maxmem 512) (memory 512) (shadow_memory 0) (vcpu_avail 7) (features ) (on_xend_start ignore) (on_xend_stop ignore) (start_time 1369930035.4) (cpu_time 4.414449199) (online_vcpus 3) (image (linux (kernel /boot/vmlinuz-2.6.32-5-amd64) (ramdisk /boot/initrd.img-2.6.32-5-amd64) (args 'root=/dev/xvda2 ro ') (superpages 0) (tsc_mode 0) (videoram 4) (pci ()) (nomigrate 0) (notes (HV_START_LOW 18446603336221196288) (FEATURES '!writable_page_tables|pae_pgdir_above_4gb') (VIRT_BASE 18446744071562067968) (GUEST_VERSION 2.6) (PADDR_OFFSET 0) (GUEST_OS linux) (HYPERCALL_PAGE 18446744071578882048) (LOADER generic) (SUSPEND_CANCEL 1) (PAE_MODE yes) (ENTRY 18446744071584211456) (XEN_VERSION xen-3.0)))) (status 2) (state -b----) (store_mfn 1190820) (console_mfn 1190819) (device (vif (bridge br-guest) (uuid 7f0b8aa6-f89d-e27c-3ba4-6db424f66858) (script /etc/xen/scripts/vif-bridge) (ip 192.168.10.12) (mac 00:16:3E:95:DE:AD) (backend 0))) (device (vif (bridge br-vmonly) (uuid aef672ce-c13d-2cb2-1b93-040c26ea87ee) (script /etc/xen/scripts/vif-bridge) (ip 192.168.11.12) (mac 00:16:3E:95:BE:EF) (backend 0))) (device (vbd (protocol x86_64-abi) (uuid 1305fde6-95c3-8716-1e73-418fca163709) (bootable 1) (dev xvda2:disk) (uname phy:/dev/etherd/e0.1) (mode w) (backend 0) (VDI ))) (device (vbd (protocol x86_64-abi) (uuid 1e934d97-a69f-f89d-2c52-78e4cee936b6) (bootable 0) (dev xvda1:disk) (uname phy:/dev/etherd/e0.2) (mode w) (backend 0) (VDI ))) (device (console (protocol vt100) (location 2) (uuid 7a60ec21-8fae-9bb0-7223-b3840d2c3c52))) (change_home_server False))
>[viele Daten mainly RAMcopy]
<(ok)
\end{verbatim}

\subsection{Fehlerhafte Migration von Xen 4.1 auf 4.0}

Es läuft wieder wie im vorherigen Abschnitt ab. Nur dass pcvirt1 und pcvirt2 vertauscht sind. Anstatt (ok) meldet pcvirt2 diese Fehlermeldung zurück.
\setupVerbatimOut
\begin{verbatim}
<(err (type "<class 'xen.xend.XendError.XendError'>") (value '/usr/lib/xen-4.0/bin/xc_restore 24 10 1 2 0 0 0 0 failed'))
\end{verbatim}

\subsection{Gratuitous ARP der VM IP/Mac}

Nach einer Erfolgreichen Migration muss, damit die Mac Tabellen der beteiligten Switches/Bridges aktuell sindm, Xen noch im Namen der VM einen sog. Gratuitous ARP Request senden dieser sieht so aus:

\setupVerbatimOut
\begin{verbatim}
151619    22.586707000    Xensourc_95:de:ad    Broadcast    ARP    42    Gratuitous ARP for 192.168.1.1 (Request)
\end{verbatim}


\chapter{VLAN für br-vmonly zwischen zwei Hosts}

Damit guest1 und guest2, wenn beiden nicht auf den selben Hostmaschinen laufen, trotzdem über br-vmlonly kommunizieren können. Muss das LAN in einem VLAN über br-guest zwischen den beiden Hosts transportiert werden. Wir wählen die VLAN ID 1234.

\section {Wheezy Upgrade für pc-virt2}

Da Gruppe 2 aus dem Praktium ausgestiegen ist, können wir den Host für unsere Zwecke nutzen. Zuerst wird wie in Kapitel \ref{chap:whezzy_ugprade} der Host auf wheezy upgegraded.

\setupVerbatimOut
\begin{verbatim}
#### Upgrade von pc-virt2 auf wheezy 
# /etc/apt/sources.list tausche squeeze durch wheezy
apt-get update
apt-get dist-upgrade -y
\end{verbatim}


\section {Open vSwitch für pc-virt2}

Anschließend muss auf pc-virt2 auch das Open vSwitch installiert werden. (Ähmlich wie in Kapitel~\ref{chap:ovs})

\setupVerbatimOut
\begin{verbatim}
### Installiere OpenVSwitch auf pc-virt2
apt-get instal openvswitch-brcompat openvswitch-switch openvswitch-datapath-dkms
modprobe openvswitch-mod

# Lösche klassische Bridge

# Erstelle beide Bridges
ovs-vsctl add-br br-guest
ovs-vsctl add-br br-vmonly
ovs-vsctl add-port br-guest eth0

# Setze  State UP
ifconfig eth0 up
ifconfig br-guest


### /etc/network/interfaces bearbeiten
## in br-guest
# Entfernde "bridge_ports" aus
# Füge "up ifconfig eth0 up" 
## bei br-vmonline
## neues abschnitt
iface br-vmonly inet manual
    up ifconfig $IFACE up
    
# Versuche Start von Guest1 auf pc-virt2
# -> geht nicht da br-compat in /etc/default/openvswitch-switch nicht aktiviert
\end{verbatim}

\section{VLAN br-vmonly über Switch}

Nun wird die Bridge br-vmonly so umgebaut, dass alle Pakete für sie über br-guest mit dem Tag 1234 laufen.

\setupVerbatimOut
\begin{verbatim}
# Füge vm-only mit tag auf br-guest (auf beiden Rechnern)
# Lösche br-vmonly temporär
ovs-vsctl del-br br-vmonly

# Füge br-vmonly mit VLAN tag 1234 auf br-guest
ovs-vsctl add-br br-vmonly br-guest 1234

# Aktiviere Brdige
ifconfig br-vmonly up

# Beide VMs runterfahren und neu starten (auf jeweils unterschiedlichen Hosts)
xm shutdown guest[12]
xm create /etc/xen/guest[12].cfg
\end{verbatim}

Nun stellt man fest, dass noch keine Kommunikation zwischen den beiden Host VMs über br-vmonly möglich ist. 
\\
$\Rightarrow$ Es muss das entsprechnde VLAN mit ID 1234 noch auf dem CISCO Switch eingerichtet werden.

\setupVerbatimOut
\begin{verbatim}
# In Configure modus gehen
switch4cd502# conf t
# Vlan 1234 erstellen
switch4cd502(config)# vlan database 
switch4cd502(config-vlan)# vlan 1234
switch4cd502(config-vlan)# exit
# Für pc-virt[123] interface mit tagged VLAN 1234 einstellen 
switch4cd502(config)# int gi9 
switch4cd502(config-if)# switchport trunk allowed vlan add 1234
switch4cd502(config-if)# exit
switch4cd502(config)# int gi11
switch4cd502(config-if)# switchport trunk allowed vlan add 1234
switch4cd502(config-if)# exit
switch4cd502(config)# int gi13
switch4cd502(config-if)# switchport trunk allowed vlan add 1234
switch4cd502(config-if)# exit
switch4cd502(config)# exit
# Speichern für nächsten Start des Switches
switch4cd502# write memory
\end{verbatim}

Nun ist br-vmonly auch zwischen den beiden Hosts möglich.


\chapter{DRBD Blockdevicesync}

Mit AOE aus Kaptiel \ref{chap:aoe} kann zwar ein Blockdevice einem anderen Host übers Netzwerk zu Verfügung gestellt werden, jedoch muss man z.B. pc-virt1 warten kann die guest1 nicht auf pc-virt2 weiterausgeführt werden, da der Festplattenspeicher nicht zur Verfügung steht. Aus diesem Grund wird nun das Swap und Root - Blockdevice einer neuen VM guest3 mittels DRBD zwischen pc-virt1 und pc-virt2 gesharet. Somit könnte in oben beschriebenen Fall pc-virt1 neugestartet werden ohne das ein Ausfall von guest3 drohen würde.

\section{DRBD installieren/konfiguieren}

Dieses Sektion wird auf beiden Hosts (pc-virt1 und pc-virt2) durchgeführt:
\setupVerbatimOut
\begin{verbatim}
# Installieren
apt-get install drbd8-utils
\end{verbatim}

Anschließend wird in den globalen Optionen die Sync Gewschwindigkeit auf 100Mbit begrenzt:
\\
\verb|/etc/drbd.d/global_config.conf|
\setupVerbatimOut
\begin{verbatim}
global { usage-count no; }
common { syncer { rate 100M; } }
\end{verbatim}

Konfiguration für Root Device:\verb|/etc/drbd.d/guest1-root.res|
\setupVerbatimOut
\begin{verbatim}
resource guest1-root {
        protocol C;
        net {
                allow-two-primaries;
                cram-hmac-alg sha1;
                shared-secret "d9a8sdtgejho3";
                after-sb-0pri discard-younger-primary; #discard-zero-changes;
                after-sb-1pri discard-secondary;
                after-sb-2pri call-pri-lost-after-sb;
        }
        on pcvirt01 {
                device /dev/drbd1;
                disk /dev/storage/drbd-guest1-root;
                address 192.168.1.131:7789;
                meta-disk internal;
        }
        on pcvirt02 {
                device /dev/drbd1;
                disk /dev/storage/drbd-guest1-root;
                address 192.168.1.132:7789;
                meta-disk internal;
        }
}
\end{verbatim}

Konfiguration für Swap Device: \verb|/etc/drbd.d/guest1-swap.res|
\setupVerbatimOut
\begin{verbatim}
resource guest1-swap {
        protocol C;
        net {
                allow-two-primaries;
                cram-hmac-alg sha1;
                shared-secret "d9a8sdtgej124";
                after-sb-0pri discard-younger-primary; #discard-zero-changes;
                after-sb-1pri discard-secondary;
                after-sb-2pri call-pri-lost-after-sb;
        }
        on pcvirt01 {
                device /dev/drbd2;
                disk /dev/storage/drbd-guest1-swap;
                address 192.168.1.131:7790;
                meta-disk internal;
        }
        on pcvirt02 {
                device /dev/drbd2;
                disk /dev/storage/drbd-guest1-swap;
                address 192.168.1.132:7790;
                meta-disk internal;
        }
}
\end{verbatim}


\section{DRBD intialisieren}

Nun wird DRBD initialisiert und das erste mal gesynct. Davor muss noch auf pc-virt2 eine LVM Volume Group eingerichtet werden:

\setupVerbatimOut
\begin{verbatim}
# Erstelle Partition über ganze Platte auf /dev/sdb mit Type 8e00
# pc-virt2 LVM einrichten
vgcreate storage /dev/sdb1 
\end{verbatim}

Anschließend auf beiden Hosts die Backend-Devices für DRBD erstellen.

\setupVerbatimOut
\begin{verbatim}
# LVs für DRBD einrichten
lvcreate -L6G -n drbd-guest1-root storage
lvcreate -L256M -n drbd-guest1-swap storage
\end{verbatim}

Starte DRBD und formatiere die Backend Devices (auf beiden Hosts)

\setupVerbatimOut
\begin{verbatim}
# Starte drbd
service drbdrstart

# Erstelle Metadata auf für DRBD Devices (jeweils auf beiden Hosts)
drbdadm create-md guest1-swap
drbdadm create-md guest1-root
\end{verbatim}


Nun wird der intiale Sync von den beiden DRBD Devices /dev/drbd1 und /dev/drbd2 durchgeführt, (nur von einem pc-virtX aus).

\setupVerbatimOut
\begin{verbatim}
# Starte intialen Sync von einem der beiden Hosts
drbdadm -- --overwrite-data-of-peer primary all

## Sync beobachten 
# Nr. 1 synct noch, Forschritt bei 12,0\%
# Nr. 2 bereits in sync sichtbar an UpToDate/UpToDate
cat /proc/drbd 
version: 8.3.11 (api:88/proto:86-96)
srcversion: 41C52C8CD882E47FB5AF767 

 1: cs:SyncSource ro:Secondary/Secondary ds:UpToDate/Inconsistent C r-----
    ns:747264 nr:0 dw:0 dr:755456 al:0 bm:44 lo:2 pe:158 ua:128 ap:0 ep:1 wo:f oos:5452576
        [=>..................] sync'ed: 12.0\% (5324/6044)Mfinish: 0:00:59 speed: 92,144 (92,144) K/sec
 2: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----
    ns:160728 nr:0 dw:0 dr:160728 al:0 bm:10 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0

# Nr. 1 s+ Nr. 2 bereits in sync sichtbar an UpToDate/UpToDate
# Sync fertig
cat /proc/drbd 
version: 8.3.11 (api:88/proto:86-96)
srcversion: 41C52C8CD882E47FB5AF767 

 1: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----
    ns:6189728 nr:0 dw:0 dr:6189728 al:0 bm:378 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0
 2: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----
    ns:160728 nr:0 dw:0 dr:160728 al:0 bm:10 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0
\end{verbatim}

Zu guter letzt müssen auf beiden Hosts noch die Devices in den Primary State versetzt werden, nur im Primary Modus stehen die Devices zum lesen und schreiben zur Verfügung.

\setupVerbatimOut
\begin{verbatim}
#  DRBD aktivieren (jeweils auf beiden Hosts)
drbdadm primary all
\end{verbatim}

\section{Guest 3 installieren}
Nun wird ein neuer Xen Guest auf den DRBD Devices installiert:
\setupVerbatimOut
\begin{verbatim}
# Installieren des Gastes
xen-create-image --ip 192.168.1.3 --bridge=br-guest  --swap-dev=/dev/drbd2 --password=123 --image-dev=/dev/drbd1 --hostname=guest3 --vcpus=2 --dist wheezy

# Starte VM
xm create /etc/xen/guest3.cfg

# Konfig Netzwerk in der VM:
cat /etc/network/interfaces
# Configure /etc/network/interfaces
# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet static
 address 192.168.1.3
 gateway 192.168.1.131
 netmask 255.255.255.0
    
# Reboot guest3
\end{verbatim}

\verb|guest3| kann frei zwischen pc-virt1 und pc-virt2 verschoben werden, dabei ist nur der Rechner nötig auf dem die VM läuft der andere kann in der Zeit offline gehen, neugestartet oder gewartet werden.
